# rembed_bot.py
# Python 3.10+
# Replit: put your token in Secrets as key "discord_bot_token" (or "DISCORD_TOKEN")
# pip install -U discord.py python-dotenv

import asyncio
import json
import os
from dataclasses import dataclass, asdict
from datetime import datetime, timedelta
from typing import Optional, Dict
from zoneinfo import ZoneInfo

import discord
from discord import app_commands
from discord.ext import commands
from dotenv import load_dotenv

SETTINGS_FILE = "settings.json"
DEFAULT_TZ = "Asia/Muscat"  # change if you like


# --------------- Persistence ---------------

def load_all_settings() -> dict:
    if not os.path.exists(SETTINGS_FILE):
        return {}
    try:
        with open(SETTINGS_FILE, "r", encoding="utf-8") as f:
            return json.load(f)
    except Exception:
        return {}

def save_all_settings(data: dict):
    tmp = SETTINGS_FILE + ".tmp"
    with open(tmp, "w", encoding="utf-8") as f:
        json.dump(data, f, indent=2)
    os.replace(tmp, SETTINGS_FILE)


@dataclass
class Rembed:
    title: str
    interval_minutes: int
    duration_minutes: int
    # schedule anchor is the *start* time of the repeating cycle
    anchor_start_iso: str
    channel_id: int
    message_id: Optional[int] = None
    enabled: bool = True

    def to_dict(self):
        return asdict(self)

    @staticmethod
    def from_dict(d: dict) -> "Rembed":
        return Rembed(**d)


@dataclass
class GuildSettings:
    timezone: str = DEFAULT_TZ
    announce_channel_id: Optional[int] = None
    # title -> Rembed (as dict for JSON)
    rembeds: Optional[dict] = None

    def to_dict(self):
        d = asdict(self)
        d["rembeds"] = {} if self.rembeds is None else self.rembeds
        return d

    @staticmethod
    def from_dict(d: dict) -> "GuildSettings":
        gs = GuildSettings()
        for k, v in d.items():
            setattr(gs, k, v)
        if gs.rembeds is None:
            gs.rembeds = {}
        return gs


# --------------- Utilities ---------------

def is_admin(inter: discord.Interaction) -> bool:
    perms = inter.user.guild_permissions
    return perms.manage_guild or perms.administrator

def parse_hhmm_to_datetime(text: str, tz: ZoneInfo, now: datetime) -> datetime:
    """
    Parse HH:MM or YYYY-MM-DD HH:MM / YYYY-MM-DDTHH:MM.
    If HH:MM given, returns the next occurrence of that wall time (today if future, else tomorrow).
    """
    s = text.strip()
    # HH:MM
    if len(s) <= 5 and ":" in s:
        hh, mm = map(int, s.split(":"))
        candidate = now.replace(hour=hh, minute=mm, second=0, microsecond=0)
        if candidate <= now:
            candidate += timedelta(days=1)
        return candidate
    # ISO-ish
    for fmt in ("%Y-%m-%d %H:%M", "%Y-%m-%dT%H:%M"):
        try:
            dt = datetime.strptime(s, fmt)
            return dt.replace(tzinfo=tz)
        except ValueError:
            pass
    raise ValueError("Could not parse time. Use HH:MM or YYYY-MM-DD HH:MM")

def parse_repeat_to_minutes(text: str) -> int:
    """
    Accepts: "90", "90m", "1h30m", "1:30", "2h", etc.
    Returns total minutes.
    """
    t = text.strip().lower()
    # 1:30
    if ":" in t and all(part.isdigit() for part in t.split(":")):
        parts = [int(x) for x in t.split(":")]
        if len(parts) == 2:
            h, m = parts
            return h * 60 + m
    # Collect simple h/m
    num = ""
    h = m = 0
    for ch in t:
        if ch.isdigit():
            num += ch
        else:
            if ch == "h" and num:
                h += int(num)
                num = ""
            elif ch == "m" and num:
                m += int(num)
                num = ""
    if num and ("h" not in t and "m" not in t):  # plain minutes like "90"
        m += int(num)
    total = h * 60 + m
    if total <= 0:
        raise ValueError("Invalid repeat format. Try 90, 90m, 1h30m, or 1:30")
    return total

def next_occurrence_after(anchor: datetime, interval: timedelta, now: datetime) -> datetime:
    """Next event start >= now given base anchor and interval."""
    if now <= anchor:
        return anchor
    delta = now - anchor
    n = int(delta.total_seconds() // interval.total_seconds()) + 1
    return anchor + n * interval

def fmt_delta_until(target: datetime, now: datetime) -> str:
    """Return human-ish remaining string, clamped at 0. e.g., '1h 29m 12s'."""
    secs = max(0, int((target - now).total_seconds()))
    h = secs // 3600
    m = (secs % 3600) // 60
    s = secs % 60
    out = []
    if h: out.append(f"{h}h")
    if h or m: out.append(f"{m}m")
    out.append(f"{s}s")
    return " ".join(out)

def find_eventping_role(guild: discord.Guild) -> Optional[discord.Role]:
    # case-insensitive match for a role literally named "eventping"
    name = "eventping"
    for role in guild.roles:
        if role.name.lower() == name:
            return role
    return None


# --------------- Scheduler Core ---------------

class RembedScheduler:
    def __init__(self, bot: commands.Bot):
        self.bot = bot
        self.settings = load_all_settings()
        # per-guild: {title: asyncio.Task}
        self.rembed_tasks: Dict[int, Dict[str, asyncio.Task]] = {}

    # settings helpers
    def get_gsettings(self, guild_id: int) -> GuildSettings:
        raw = self.settings.get(str(guild_id))
        return GuildSettings.from_dict(raw) if raw else GuildSettings()

    def put_gsettings(self, guild_id: int, gs: GuildSettings):
        self.settings[str(guild_id)] = gs.to_dict()
        save_all_settings(self.settings)

    async def ensure_rembed_tasks(self, guild: discord.Guild):
        gs = self.get_gsettings(guild.id)
        if not gs.rembeds:
            return
        self.rembed_tasks.setdefault(guild.id, {})
        tz = ZoneInfo(gs.timezone)
        for title, data in list(gs.rembeds.items()):
            # skip disabled
            if isinstance(data, dict) and not data.get("enabled", True):
                # cancel if exists
                t = self.rembed_tasks[guild.id].pop(title, None)
                if t: t.cancel()
                continue
            # already running?
            existing = self.rembed_tasks[guild.id].get(title)
            if existing and not existing.done():
                continue
            # spin a loop
            task = asyncio.create_task(self._rembed_loop(guild, title, data, tz))
            self.rembed_tasks[guild.id][title] = task

    async def _sleep_until(self, when: datetime, tz: ZoneInfo):
        # gentle, frequent wake-ups to be accurate
        while True:
            now = datetime.now(tz)
            remain = (when - now).total_seconds()
            if remain <= 0:
                return
            await asyncio.sleep(min(30, remain))

    async def _notify_after(self, channel: discord.TextChannel, delay: timedelta, text: str):
        await asyncio.sleep(max(0, delay.total_seconds()))
        try:
            await channel.send(text)
        except Exception:
            pass

    async def _rembed_loop(self, guild: discord.Guild, title: str, data: dict, tz: ZoneInfo):
        # load rembed
        try:
            rem = Rembed.from_dict(data)
        except Exception:
            return
        # channel
        try:
            channel = guild.get_channel(rem.channel_id) or await self.bot.fetch_channel(rem.channel_id)
        except Exception:
            return

        interval = timedelta(minutes=rem.interval_minutes)
        duration = timedelta(minutes=rem.duration_minutes)
        anchor_start = datetime.fromisoformat(rem.anchor_start_iso)
        if anchor_start.tzinfo is None:
            anchor_start = anchor_start.replace(tzinfo=tz)

        # precompute role mention (if present)
        ping_role = find_eventping_role(guild)
        ping_text = f"{ping_role.mention} " if ping_role else ""

        while True:
            now = datetime.now(tz)
            next_start = next_occurrence_after(anchor_start, interval, now)
            await self._sleep_until(next_start, tz)

            # Compute end and post/edit embed
            event_end = next_start + duration
            now = datetime.now(tz)

            embed = discord.Embed(title=title, color=0x2b2d31)
            embed.add_field(name="Time until next event", value=f"`{fmt_delta_until(next_start, now)}`", inline=False)
            embed.add_field(name="Event ends in", value=f"`{fmt_delta_until(event_end, now)}`", inline=False)
            embed.set_footer(text=f"Repeats every {rem.interval_minutes} min • Duration {rem.duration_minutes} min • {tz.key}")

            try:
                if rem.message_id:
                    try:
                        existing = await channel.fetch_message(rem.message_id)
                        await existing.edit(content=f"{ping_text}▶️ Event STARTED", embed=embed, allowed_mentions=discord.AllowedMentions(roles=True))
                    except Exception:
                        msg = await channel.send(content=f"{ping_text}▶️ Event STARTED", embed=embed, allowed_mentions=discord.AllowedMentions(roles=True))
                        rem.message_id = msg.id
                else:
                    msg = await channel.send(content=f"{ping_text}▶️ Event STARTED", embed=embed, allowed_mentions=discord.AllowedMentions(roles=True))
                    rem.message_id = msg.id
            except Exception:
                # can't send right now; try later
                await asyncio.sleep(30)
                continue

            # persist message id
            gs = self.get_gsettings(guild.id)
            gs.rembeds[title] = rem.to_dict()
            self.put_gsettings(guild.id, gs)

            # live update until both timers elapsed
            while True:
                now = datetime.now(tz)
                if now >= next_start and now >= event_end:
                    break
                try:
                    upd = discord.Embed(title=title, color=0x2b2d31)
                    upd.add_field(name="Time until next event", value=f"`{fmt_delta_until(next_start, now)}`", inline=False)
                    upd.add_field(name="Event ends in", value=f"`{fmt_delta_until(event_end, now)}`", inline=False)
                    upd.set_footer(text=f"Repeats every {rem.interval_minutes} min • Duration {rem.duration_minutes} min • {tz.key} • Updated {now.strftime('%H:%M:%S')}")
                    await channel.get_partial_message(rem.message_id).edit(embed=upd)
                except Exception:
                    pass
                await asyncio.sleep(60)

            # end ping (no role ping by default to avoid spam)
            asyncio.create_task(self._notify_after(channel, duration, f"⏰ {title}: Event ENDED."))

            # pre-start reminder 5 min before next start (ping the role)
            if rem.interval_minutes >= 10:
                remind_at = next_start + interval - timedelta(minutes=5)
                delay = remind_at - now
                asyncio.create_task(self._notify_after(channel, delay, f"{ping_text}⌛ {title}: 5 minutes until next event."))


# --------------- Bot & Commands ---------------

intents = discord.Intents.default()
intents.message_content = False  # not needed for slash commands
bot = commands.Bot(
    command_prefix="!",
    intents=intents,
    allowed_mentions=discord.AllowedMentions(roles=True, users=True, everyone=False),
)
sched = RembedScheduler(bot)


@bot.event
async def on_ready():
    print(f"Logged in as {bot.user} (ID: {bot.user.id})")
    try:
        await bot.tree.sync()
        print("Slash commands synced.")
    except Exception as e:
        print("Sync error:", e)
    # ensure loops for existing guilds
    for g in bot.guilds:
        await sched.ensure_rembed_tasks(g)


@bot.event
async def on_guild_join(guild):
    await sched.ensure_rembed_tasks(guild)


def _get_gs(guild: discord.Guild) -> GuildSettings:
    return sched.get_gsettings(guild.id)

def _save_gs(guild: discord.Guild, gs: GuildSettings):
    sched.put_gsettings(guild.id, gs)


# ---- basic server config (admin only) ----

@bot.tree.command(description="Set the default channel for rembeds.")
@app_commands.describe(channel="Channel where rembed embeds will be posted unless overridden")
async def set_channel(interaction: discord.Interaction, channel: discord.TextChannel):
    if not is_admin(interaction):
        return await interaction.response.send_message("Admins only.", ephemeral=True)
    gs = _get_gs(interaction.guild)
    gs.announce_channel_id = channel.id
    _save_gs(interaction.guild, gs)
    await interaction.response.send_message(f"Default channel set to {channel.mention}.", ephemeral=True)

@bot.tree.command(description="Set the server timezone for timers, e.g., Asia/Muscat or UTC.")
async def set_timezone(interaction: discord.Interaction, tz_name: str):
    if not is_admin(interaction):
        return await interaction.response.send_message("Admins only.", ephemeral=True)
    try:
        ZoneInfo(tz_name)
    except Exception:
        return await interaction.response.send_message("Invalid timezone. Try e.g. UTC, Europe/London, Asia/Muscat.", ephemeral=True)
    gs = _get_gs(interaction.guild)
    gs.timezone = tz_name
    _save_gs(interaction.guild, gs)
    await interaction.response.send_message(f"Timezone set to {tz_name}.", ephemeral=True)


# ---- Rembeds (admin only) ----

rembed = app_commands.Group(name="rembed", description="Create and manage repeating embed timers")

@rembed.command(name="create", description="Create a repeating embed timer")
@app_commands.describe(
    title="Title of this timer embed",
    endtime="Current event end time (HH:MM or YYYY-MM-DD HH:MM)",
    repeatafter="Interval between event starts (e.g., 1:30, 90m, 1h30m)",
    duration_minutes="Event duration in minutes (default 20)",
    channel="Channel to post the embed (defaults to /set_channel)",
)
async def rembed_create(
    interaction: discord.Interaction,
    title: str,
    endtime: str,
    repeatafter: str,
    duration_minutes: app_commands.Range[int, 1, 240] = 20,
    channel: Optional[discord.TextChannel] = None,
):
    if not is_admin(interaction):
        return await interaction.response.send_message("Admins only.", ephemeral=True)

    gs = _get_gs(interaction.guild)
    tz = ZoneInfo(gs.timezone)
    now = datetime.now(tz)

    if channel is None:
        if not gs.announce_channel_id:
            return await interaction.response.send_message("No default channel set. Use /set_channel or pass a channel.", ephemeral=True)
        channel_id = gs.announce_channel_id
    else:
        channel_id = channel.id

    try:
        end_dt = parse_hhmm_to_datetime(endtime, tz, now)
        interval_m = parse_repeat_to_minutes(repeatafter)
    except ValueError as e:
        return await interaction.response.send_message(str(e), ephemeral=True)

    start_dt = end_dt - timedelta(minutes=duration_minutes)
    rem = Rembed(
        title=title,
        interval_minutes=interval_m,
        duration_minutes=duration_minutes,
        anchor_start_iso=start_dt.isoformat(),
        channel_id=channel_id,
        message_id=None,
        enabled=True,
    )

    gs.rembeds[title] = rem.to_dict()
    _save_gs(interaction.guild, gs)
    await sched.ensure_rembed_tasks(interaction.guild)
    await interaction.response.send_message(
        f"Rembed **{title}** created. First start at **{start_dt.strftime('%Y-%m-%d %H:%M %Z')}**.",
        ephemeral=True
    )

@rembed.command(name="delete", description="Delete a rembed and stop its timer.")
@app_commands.describe(title="Title of the rembed to delete")
async def rembed_delete(interaction: discord.Interaction, title: str):
    if not is_admin(interaction):
        return await interaction.response.send_message("Admins only.", ephemeral=True)
    gs = _get_gs(interaction.guild)
    if title not in gs.rembeds:
        return await interaction.response.send_message("No rembed with that title.", ephemeral=True)
    data = gs.rembeds.pop(title)
    _save_gs(interaction.guild, gs)
    # cancel task if running
    t = sched.rembed_tasks.get(interaction.guild_id, {}).pop(title, None)
    if t:
        t.cancel()
    # try delete message
    try:
        channel = await bot.fetch_channel(data["channel_id"])  # type: ignore
        if data.get("message_id"):
            msg = await channel.fetch_message(data["message_id"])  # type: ignore
            await msg.delete()
    except Exception:
        pass
    await interaction.response.send_message(f"Deleted rembed **{title}**.", ephemeral=True)

@rembed.command(name="list", description="List rembeds in this server.")
async def rembed_list(interaction: discord.Interaction):
    if not is_admin(interaction):
        return await interaction.response.send_message("Admins only.", ephemeral=True)
    gs = _get_gs(interaction.guild)
    if not gs.rembeds:
        return await interaction.response.send_message("No rembeds yet.", ephemeral=True)
    lines = []
    for t, d in gs.rembeds.items():
        lines.append(f"• {t} — every {d['interval_minutes']}m, duration {d['duration_minutes']}m")
    await interaction.response.send_message("\n".join(lines), ephemeral=True)

@rembed.command(name="set", description="Edit a rembed's settings.")
@app_commands.describe(
    title="Which rembed to edit",
    new_title="Rename the rembed",
    repeatafter="New repeat interval (e.g., 1:30, 90m)",
    duration_minutes="New duration in minutes",
    next_endtime="Set the NEXT event end time (re-anchors schedule)",
)
async def rembed_set(
    interaction: discord.Interaction,
    title: str,
    new_title: Optional[str] = None,
    repeatafter: Optional[str] = None,
    duration_minutes: Optional[int] = None,
    next_endtime: Optional[str] = None,
):
    if not is_admin(interaction):
        return await interaction.response.send_message("Admins only.", ephemeral=True)
    gs = _get_gs(interaction.guild)
    if title not in gs.rembeds:
        return await interaction.response.send_message("No rembed with that title.", ephemeral=True)

    tz = ZoneInfo(gs.timezone)
    now = datetime.now(tz)
    rem = Rembed.from_dict(gs.rembeds[title])

    if repeatafter is not None:
        rem.interval_minutes = parse_repeat_to_minutes(repeatafter)
    if duration_minutes is not None:
        rem.duration_minutes = int(duration_minutes)
    if next_endtime is not None:
        end_dt = parse_hhmm_to_datetime(next_endtime, tz, now)
        rem.anchor_start_iso = (end_dt - timedelta(minutes=rem.duration_minutes)).isoformat()
    # rename if needed
    if new_title:
        gs.rembeds.pop(title)
        title = new_title
        rem.title = new_title

    gs.rembeds[title] = rem.to_dict()
    _save_gs(interaction.guild, gs)
    await sched.ensure_rembed_tasks(interaction.guild)
    await interaction.response.send_message("Updated.", ephemeral=True)

# register group
bot.tree.add_command(rembed)


# --------------- Main ---------------

if __name__ == "__main__":
    load_dotenv()  # harmless on Replit; useful locally
    token = (
        os.getenv("DISCORD_TOKEN")
        or os.getenv("discord_bot_token")        # Replit secret key (yours)
        or os.getenv("DISCORD_BOT_TOKEN")        # common alt
    )
    if not token:
        raise SystemExit("Missing bot token. Set DISCORD_TOKEN or discord_bot_token environment variable.")
    bot.run(token)
